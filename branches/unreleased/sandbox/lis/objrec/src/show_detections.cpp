/*
 * show_detections.cpp
 *
 *  Created on: Sep 14, 2012
 */

#include "detection.h"
#include "draw.h"
#include <iostream>
#include <sys/stat.h>

struct detection {
	objrec::localization loc;
	unsigned short x0, x1, y0, y1;
	objrec::viewpoint vp;
	std::string object_file;
	std::string image_file;
};

int main(int argc, char** argv) {
	if(argc<2) {
		std::cout << "usage:" << std::endl;
		std::cout << " " << std::string(argv[0]) << " [-ignore_edges] [-output_images] mesh_file detections_file1 detections_file2 ..." << std::endl;
		std::cout << std::endl;
		std::cout << "Displays detection files generated by image_detect." << std::endl;
		std::cout << "Including the '-ignore_edges' option skips loading the precomputed .edges file for each image." << std::endl;
		std::cout << "Including the '-output_images' option outputs png files plus an output.html file in /tmp/show_detections." << std::endl;
		return -1;
	}

	std::cout << "up/down:          change between detections for an image" << std::endl;
	std::cout << "left/right/space: change between images" << std::endl;
	std::cout << "q/esc:            quit" << std::endl;

	std::string last_image_file = "";
	std::string last_object_file = "";
	objrec::object obj;
	cv::Mat_<cv::Vec3b> picture, edges_bgr, textons_bgr, depth_bgr;
	objrec::image* im = 0;

	int current_detections_file = 1;
	bool ignore_edges = false;
	bool output_images = false;
	bool found_switch = true;
	while(found_switch) {
		if(std::string("-ignore_edges")==argv[current_detections_file]) {
			ignore_edges = true;
			current_detections_file++;
		} else if(std::string("-output_images")==argv[current_detections_file]) {
			output_images = true;
			current_detections_file++;
		} else {
			found_switch = false;
		}
	}

	std::string mesh_file = argv[current_detections_file];
	objrec::OpenGL_X_window w;
	objrec::mesh m = objrec::load_off(mesh_file);

	std::string mesh_dir = mesh_file.substr(mesh_file.find_last_of('/')+1);

	if(output_images) {
		mkdir("/tmp/show_detections",0777);
		mkdir((std::string("/tmp/show_detections/")+mesh_dir).c_str(),0777);
		std::ofstream out("/tmp/show_detections/output.html",std::ios::app);
		out << "<br/><b>" << mesh_dir << "</b>" << std::endl;
		out << "<table><tbody><tr><th><small>rz diff<br/>(degrees)</small></th><th><small>distance (cm)</small></th></tr>" << std::endl;
	}


	current_detections_file++;

	int first_detections_file = current_detections_file;
	bool current_detections_file_increase = true;
	bool quit = false;
	while(!quit) {

		std::cout << "reading '" << argv[current_detections_file] << "'..." << std::flush;
		std::ifstream in(argv[current_detections_file]);
		int line_number = 0;

		std::vector<detection> detections;
		while(in.good()) {
			try {
				std::istringstream line(objrec::nextline(in, line_number));
				detection d;
				line >> d.loc.log_probability >> d.x0 >> d.x1 >> d.y0 >> d.y1
					>> d.loc.location >> d.vp >> d.object_file >> d.image_file;
				detections.push_back(d);
			}
			catch(...) {
				break;
			}
		}
		std::cout << " done. (" << detections.size() << " detections)" << std::endl;
		if(detections.size()==0) {
			if(current_detections_file_increase) {
				current_detections_file++;
				if(current_detections_file>=argc-1) {
					current_detections_file_increase = false;
				}
			}
			else {
				current_detections_file--;
				if(current_detections_file<=2) {
					current_detections_file_increase = true;
				}
			}
			continue;
		}

		int current_detection = 0;
		bool change_files = false;
		while(!quit && !change_files) {
			std::cout << "detection " << current_detection+1 << " of " << detections.size() << std::endl;
			const detection& d = detections[current_detection];
			if(d.object_file!=last_object_file) {
				std::ifstream obj_in(d.object_file.c_str());
				if(!obj_in) throw std::runtime_error("Could not open object file '"+d.object_file+"'.");
				std::cout << "reading '" << d.object_file << "'..." << std::flush;
				obj_in >> obj;
				std::cout << " done." << std::endl;
			}
			last_object_file = d.object_file;

			if(d.image_file!=last_image_file) {
				std::cout << "reading and preprocessing '" << d.image_file << "'..." << std::flush;
				picture = objrec::read_image(d.image_file);
				cv::Mat_<float> depth = objrec::read_depth(objrec::corresponding_depth_file(d.image_file));
				std::string precomputed_edges_file = objrec::corresponding_edges_file(d.image_file);
				std::vector<cv::Mat_<float> > precomputed_edges;
				if(!ignore_edges && precomputed_edges_file!="") {
					objrec::read_edges(precomputed_edges_file,
							//output parameter:
							precomputed_edges);
					edges_bgr = objrec::edges_bgr(precomputed_edges,obj.library.get_edges());
				} else {
					edges_bgr = objrec::edges_bgr(picture, depth, obj.library.get_edges());
				}
				depth_bgr = objrec::mat_bgr((cv::Mat_<float>)-depth);
				textons_bgr = objrec::textons_bgr(picture,obj.library.get_textons());
				cv::imshow("edges",edges_bgr);
				cv::imshow("depth",depth_bgr);
				cv::imshow("textons",textons_bgr);
				cv::imshow("original",picture);
				cv::imshow("picture",picture);
				cv::imshow("rendered",objrec::draw_combined_mesh(picture,depth,m,d.loc.location,w));
				cv::imshow("superimposed",objrec::draw_superimposed_mesh(picture,m,d.loc.location,w));
				cv::waitKey(100);
				//Since we will not be searching on the image, we don't need the depth summed area table.
				//We can reduce the size of that table and the time it takes to compute it by setting ddepth to 5.0.
				float ddepth = 5.0;
				if(im!=0) delete im;
				im = new objrec::image(obj.library,picture,depth,precomputed_edges,ddepth);
				std::cout << " done." << std::endl;

				if(output_images) {
					objrec::point p;
					size_t dot = d.image_file.find_last_of('.');
					std::string pose_file = d.image_file.substr(0,dot)+".pose";
					{
						std::ifstream in(pose_file.c_str());
						if(in) {
							in >> p;
							std::cerr << "read existing pose file from " << pose_file << "." << std::endl;
						}
					}
					size_t j = d.image_file.find_last_of('/')+1;
					std::string basename = d.image_file.substr(j);
					cv::imwrite("/tmp/show_detections/"+mesh_dir+"/"+basename+"_original.png",picture);
					cv::imwrite("/tmp/show_detections/"+mesh_dir+"/"+basename+"_rendered.png",objrec::draw_combined_mesh(picture,depth,m,d.loc.location,w));
					cv::imwrite("/tmp/show_detections/"+mesh_dir+"/"+basename+"_superimposed.png",objrec::draw_superimposed_mesh(picture,m,d.loc.location,w));
					{
						std::ofstream out(std::string("/tmp/show_detections/"+mesh_dir+"/"+basename+".html").c_str());
						out << "<img src='" << basename << "_original.png'>";
						out << "<img src='" << basename << "_rendered.png'>";
						out << "<img src='" << basename << "_superimposed.png'>";
					}
					{
						std::ofstream out(std::string("/tmp/show_detections/output.html").c_str(),std::ios::app);
						const objrec::point& p2 = d.loc.location;
						double rz_diff = p.rz - p2.rz;
						double f = 525;
						double x1 = p.depth*p.x/sqrt(f*f+p.x*p.x);
						double y1 = p.depth*p.y/sqrt(f*f+p.y*p.y);
						double z1 = sqrt(p.depth*p.depth-x1*x1-y1*y1);
						double x2 = p2.depth*p2.x/sqrt(f*f+p2.x*p2.x);
						double y2 = p2.depth*p2.y/sqrt(f*f+p2.y*p2.y);
						double z2 = sqrt(p2.depth*p2.depth-x2*x2-y2*y2);
						double dx = x2 - x1;
						double dy = y2 - y1;
						double dz = z2 - z1;
						double dist = sqrt(dx*dx+dy*dy+dz*dz);
						std::string a = "<a href='"+mesh_dir+"/"+basename+".html'>";
						out << "<tr><td>" << a << rz_diff << "</a></td><td>" << a << dist*100 << "</a></td></tr>" << std::endl;
					}

				}
			}
			last_image_file = d.image_file;

			objrec::view* v = 0;
			for(std::vector<objrec::view>::iterator j=obj.views.begin();j!=obj.views.end();j++) {
				if(d.vp == j->get_viewpoint()) {
					v = &*j;
				}
			}
			if(v==0) {
				std::ostringstream out;
				out << "Could not find viewpoint '" << d.loc.v->get_viewpoint() << "' in the object file '" << d.object_file << "'."
						<< " Has the file changed since it was used to generate the detection file ('"
						<< argv[current_detections_file] << "')?";
				throw std::runtime_error(out.str());
			}
			//cv::imshow("view",objrec::view_image(*v,l.location.depth));

			objrec::localization this_localization;
			float log_p = im->max_log_probability(*v,d.loc.location);
			this_localization.location = d.loc.location;
			this_localization.log_probability = log_p;
			this_localization.v = v;
//			float x0, x1, y0, y1;
//			v->get_bounding_box(d.loc.location,x0,x1,y0,y1);
//			this_localization.x0 = round(x0);
//			this_localization.x1 = round(x1);
//			this_localization.y0 = round(y0);
//			this_localization.y1 = round(y1);

			float edge_probability = im->max_log_visual_parts_probability(*v,this_localization.location);
			float depth_probability = im->max_log_depth_parts_probability(*v,this_localization.location);

			std::cout << "log_probability: " << this_localization.log_probability <<
					" from edges: " << edge_probability << " from depth: " << depth_probability << std::endl;

			if(d.loc.log_probability!=this_localization.log_probability) {
				std::cout << "              from file: " << d.loc.log_probability
						<< " (difference of " << d.loc.log_probability-this_localization.log_probability
						<< ")" << std::endl;
			}

			cv::Mat_<cv::Vec3b> modified_picture = picture.clone();
			cv::Mat_<cv::Vec3b> modified_edges_bgr = edges_bgr.clone();
			cv::Mat_<cv::Vec3b> modified_textons_bgr = textons_bgr.clone();
			cv::Mat_<cv::Vec3b> modified_depth_bgr = depth_bgr.clone();
			im->draw(*v,this_localization.location,modified_picture);
//			objrec::draw(this_localization,*im,
//					modified_picture,modified_edges_bgr,modified_textons_bgr,modified_depth_bgr);
			cv::imshow("edges",modified_edges_bgr);
			cv::imshow("depth",modified_depth_bgr);
			cv::imshow("textons",modified_textons_bgr);
			cv::imshow("picture",modified_picture);

			int key = cv::waitKey(0);
			switch(key) {
			case 65364: //down arrow
			case 1113940: //down arrow with num lock
				if(current_detection<(int)detections.size()-1) {
					current_detection++;
				}
				break;
			case 65362: //up arrow
			case 1113938: //up arrow with numlock
				if(current_detection>0) {
					current_detection--;
				}
				break;
			case 113: //q
			case 1048689: //q with numlock
			case 27: //esc
			case 1048603: //esc with numlock
				quit = true;
				if(output_images) {
					std::ofstream out("/tmp/show_detections/output.html",std::ios::app);
					out << "</tbody></table><br/>" << std::endl;
				}
				break;
			case 65363: //right arrow
			case 1113939: //right arrow with num lock
			case 32: //space
			case 1048608: //space with num lock
				if(current_detections_file<argc-1) {
					current_detections_file++;
					current_detections_file_increase = true;
					current_detection = 0;
					change_files = true;
				}
				break;
			case 65361: //left arrow
			case 1113937: //left arrow with num lock
				if(current_detections_file>first_detections_file) {
					current_detections_file--;
					current_detections_file_increase = false;
					current_detection = 0;
					change_files = true;
				}
				break;
			default:
				std::cout << "Unrecognized key pressed: " << key << std::endl;
				break;
			}
		}
	}
	if(im!=0) delete im;
}
